'''
https://leetcode-cn.com/problems/longest-increasing-subsequence/

300. 最长上升子序列 （字节跳动、亚马逊、微软在半年内面试中考过）

思路：
一、使用回溯，可以得到输入数组的所有子序列，时间复杂度为O(2^N)；再对这些子序列依次判断是否为严格上升，
时间复杂度为O(N)，所以总的时间复杂度为O(N 2^N)

二、DP，O(N^2)
为了从一个较短的上升子序列得到一个较长的上升子序列，我们主要关心这个较短的上升子序列结尾的元素。
由于要保证子序列的相对顺序，在程序读到一个新的数的时候，如果比已经得到的子序列的最后一个数还大，
那么就可以放在这个子序列的最后，形成一个更长的子序列；

dp[i] 表示以 nums[i] 结尾的「上升子序列」的长度。
注意：这个定义中 nums[i] 必须被选取，且必须是这个子序列的最后一个元素。

遍历到 nums[i] 时，需要把下标 i 之前的所有的数都看一遍；
只要 nums[i] 严格大于在它位置之前的某个数，那么 nums[i] 就可以接在这个数后面形成一个更长的上升子序列；
因此，dp[i] 就等于下标 i 之前严格小于 nums[i] 的状态值的最大者 +1。
dp[i] = max(dp[j] for j < i if nums[j] < nums[i]) + 1

输出要注意，不能返回最后一个状态值；
还是根据定义，最后一个状态值只是以 nums[len - 1] 结尾的「上升子序列」的长度；
状态数组 dp 的最大值才是最后要输出的值

遍历到一个新数的时候，之前所有的状态值都得保留，因此无法压缩。

三、如果已经得到的上升子序列的结尾的数越小，就会有更大的可能性构成一个更长的上升子序列；
既然结尾越小越好，我们可以记录在长度固定的情况下，结尾最小的那个元素的数值，
这样定义也是为了方便得到「状态转移方程」

tail[i] 表示长度为 i + 1 的所有上升子序列的结尾的最小值



'''


def lengthOfLIS(self, nums: List[int]) -> int:
    '''
    动态规划
    O(N^2)
    '''
    n = len(nums)
    if n < 2:
        return n
    dp = [1] * n
    for i in range(1, n):
        for j in range(i):
            if nums[j] < nums[i]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)


